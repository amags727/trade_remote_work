clear all; close all; clc;
addpath(genpath('../e_helper_functions'))

% production parameters 
w = 1; % wage
phi_g = 1; % goods productivity
gamma = 4;     % CES parameter (from BEJK)
gamma_tilde = gamma/(gamma-1);
nu = .25;
% data parameters 
phi_d = 1; % data productivity 
alpha_1 = .5; % cobb douglas coefficient on data labor 
alpha_2 = .5; % cobb douglas coefficient on raw data 
sigma_a = 1.1; % sd of noise term 
sqrt_Q = 1.1; % sd of random component of z
Q = sqrt_Q^2;
theta = .25; % mean reversion parameter of z (closer to one faster mean reversion)

% Simulation Parameters
rho = 0.05; %discount rate
Delta = 1000; % 1/Delta = time_step
crit = 10^(-6);
maxit = 500;

% define state space boundaries for both z; z_hat; a
z_ub = 2.576*sqrt_Q / sqrt(2*theta); % 99th percentile of stationary distrib
z_lb = -z_ub; %1st percentile of stationary distrib 

% define state boundaries for Sigma 
Sigma_ub = Q /(2*theta); % Sigma_ub is the value such that drift = 0 when the firm doesn't participate in market 
Sigma_lb = 1e-2;

% define the state space; 
I = 10;
num_state_vars = 4;
lb = [repmat(z_lb,1,3), Sigma_lb]; ub = [repmat(z_ub,1,3), Sigma_ub];
grid_vectors = cell(1, num_state_vars);
for i = 1:length(lb)
    grid_vectors{i} = linspace(lb(i), ub(i), I);
end

grid = cell(1, length(lb)); [grid{:}] = ndgrid(grid_vectors{:});
grid_matrix = cellfun(@(x) x(:), grid, 'UniformOutput', false);
state_space = [grid_matrix{:}];
z_act = state_space(:,1); z_hat = state_space(:,2); 
a_act = state_space(:,3); Sigma = state_space(:,4);
len_state = size(state_space,1);
d_state_space = (ub - lb) / (I-1);

% Define Expected Quality (A_tilde) and related values 
C = (Sigma_ub + sigma_a^2);
ndraws = 10000;
eta = randn(len_state,10000) .*repmat((Sigma+ sigma_a^2).^(1/2),1,ndraws) +...
    repmat((a_act - z_hat),1,ndraws);
penalty =  mean(C*eta.^2 ./(eta.^2 +C),2);
A_bar = max(penalty) + (max(penalty)-min(penalty));
A_tilde = A_bar - penalty;
x_bar = 1/min(A_tilde); % base demand 
pi_bar = x_bar*w*phi_g^-1*(gamma-1)^-1; % base profits 
E_x = x_bar*A_tilde;
E_pi = pi_bar*A_tilde;
xi = alpha_1*phi_d*E_x.^alpha_2;

% guess v_0; 
% all states have long term profits of a perfectly forecast a, with
% Sigma set at ss value with no data investment 
R_0 = sigma_a^2;
Sigma_0 = -theta*R_0 + sqrt(theta^2*R_0^2 + Q*R_0);
[~, idx] = min(abs(Sigma - Sigma_0));
idx_0 = find(z_hat == a_act & Sigma== Sigma(idx),1, 'first' );
V_0 = repmat(A_tilde(idx_0)*pi_bar / rho, len_state,1);
v= V_0;


%% Perform value func iteration 
for n=1:maxit
V= v;
[dv_f, dv_b, dv_2] = e1_compute_derivatives(v, d_state_space,I, num_state_vars, len_state);



% Carry out the updwind 
% === SETUP ===
Ib = false(len_state,num_state_vars); If = Ib; I_final = Ib;
dv_min = min(dv_b, dv_f); dv_max = max(dv_b, dv_f); dv_final = zeros(size(dv_b));
z_vec = zeros(len_state, 1);
z_greater_z_hat_mat = repmat(z_act > z_hat, 1, num_state_vars);

% === 1. Deterministic drift directions ===

% (1) z: drift = -theta * z → backward if z > 0
Ib(z_act > 0,1) = true; If(z_act <= 0 , 1) = true;

% (3) a: drift ∝ sign of v_a → use direction only if sign is consistent
Ib(dv_max(:,3) < 0, 3) = true; If(dv_min(:,3) > 0, 3) = true; 

% mark finalized entries and set finalized values 
I_final(:,[1,3]) = true;
dv_final(Ib) = dv_b(Ib); dv_final(If) = dv_f(If);

% resolve ẑ and Σ by iteratively checking best / work case scenarios 
for place_holder = 1:2
    % === 2. Resolve ẑ (column 2) via worst-case derivative combinations ===
    % For z_hat: b(z_hat) ⬆️ in v_zhat and ⬇️ in v_Sigma

    % Worst-case for drift ≥ 0
    dv_bzhat_min = I_final.*dv_final...
        + (~I_final).*[z_vec, dv_min(:,2), z_vec, dv_max(:,4)];
    temp = e1_optim_calc(dv_bzhat_min, dv_2, w, z_act, z_hat, Sigma, xi, alpha_1, alpha_2, nu, phi_d, sigma_a, theta, Q, E_x, E_pi);
    If(temp.drift.z_hat >= 0,2) = true;

    % Worst-case for drift < 0
    dv_bzhat_max = I_final.*dv_final...
        + (~I_final).*[z_vec, dv_max(:,2), z_vec, dv_min(:,4)];
    temp = e1_optim_calc(dv_bzhat_max , dv_2, w, z_act, z_hat, Sigma, xi, alpha_1, alpha_2, nu, phi_d, sigma_a, theta, Q, E_x, E_pi);
    Ib(temp.drift.z_hat < 0,2) = true;

    I_final(:,2) = Ib(:,2) | If(:,2);
    dv_final(Ib) = dv_b(Ib); dv_final(If) = dv_f(If);

    if i ~=2
        % === 3. Resolve Σ (column 4) via conditional worst-case logic ===
        % For Sigma:
        % If z > z_hat: b(Sigma) ⬇️ in v_zhat and ⬆️ in v_Sigma
        % If z < z_hat: b(Sigma) ⬆️ in v_zhat and ⬆️ in v_Sigma
        % Worst-case for drift ≥ 0
        dv_bSigma_min = I_final.*dv_final...
            + (~I_final & z_greater_z_hat_mat) .*[z_vec, dv_max(:,2), z_vec, dv_min(:,4)]...
            + (~I_final & ~z_greater_z_hat_mat) .*[z_vec, dv_min(:,2), z_vec, dv_min(:,4)];
        temp = e1_optim_calc(dv_bSigma_min, dv_2, w, z_act, z_hat, Sigma, xi, alpha_1, alpha_2, nu, phi_d, sigma_a, theta, Q, E_x, E_pi);
        If(temp.drift.Sigma >= 0,4) = true;

        % Worst-case for drift < 0
        dv_bSigma_max = I_final.*dv_final...
            + (~I_final & z_greater_z_hat_mat) .*[z_vec, dv_min(:,2), z_vec, dv_max(:,4)]...
            + (~I_final & ~z_greater_z_hat_mat) .*[z_vec, dv_max(:,2), z_vec, dv_max(:,4)];
        temp = e1_optim_calc(dv_bSigma_max, dv_2, w, z_act, z_hat, Sigma, xi, alpha_1, alpha_2, nu, phi_d, sigma_a, theta, Q, E_x, E_pi);
        Ib(temp.drift.Sigma < 0,4) = true;
        I_final(:,4) = Ib(:,4) | If(:,4);
        dv_final(Ib) = dv_b(Ib); dv_final(If) = dv_f(If);
    end
end

rows_with_ambiguity = find(any(~I_final, 2));
for i = rows_with_ambiguity
    known_columns = find(I_final(i,:)==1);
    unknown_columns = find(I_final(i,:)==0);
    num_combos = 2^size(unknown_columns,2);
    combos = dec2bin(0:num_combos-1) - '0';   % size: (2^k) × k
    combo_matrix = repmat(dv_b(i,:), num_combos, 1);  % default to dv_b
    
    for j = 1:size(unknown_columns,2)
        col = unknown_columns(j);
        combo_matrix(:,col) = (1 - combos(:,j)) .* dv_b(i,col) + combos(:,j) .* dv_f(i,col);
    end

    optim = e1_optim_calc(combo_matrix, ...
        repmat(dv_2(i,:), num_combos, 1),w, ...
        repmat(z_act(i),num_combos,1), ...
        repmat(z_hat(i), num_combos,1), ...
        repmatSigma, xi, alpha_1, alpha_2, nu, phi_d, sigma_a, theta, Q, E_x, E_pi)
   
    


end













% Carry out the updwind 
Ib = false(len_state,num_state_vars); If = Ib; I_final = If;
   
for i = 1:num_state_vars
     dv_b_temp = dv_b; dv_b_temp(If) = dv_f(If);
     dv_f_temp = dv_f; dv_f_temp(Ib) = dv_b(Ib); 
     optim_f =  e1_optim_calc(dv_f_temp, dv_2, w, z_act, z_hat, Sigma, xi, alpha_1, alpha_2, nu, phi_d, sigma_a, theta, Q, E_x, E_pi);
     optim_b =  e1_optim_calc(dv_b_temp, dv_2, w, z_act, z_hat, Sigma, xi, alpha_1, alpha_2, nu, phi_d, sigma_a, theta, Q, E_x, E_pi);
     
     Iunique = optim_f.drift.overall .* optim_b.drift.overall >= 0;
     Ib = Iunique & optim_f.drift.overall <= 0;
     If = Iunique & optim_f.drift.overall > 0;

     if all(Iunique(:)) || isequal(Iunique, I_final)
         break
     else
         I_final = Iunique;
     end
end
Ib = Ib | (~I_final & optim_f.ham_rep <= optim_b.ham_rep);
If = If | (~I_final & optim_f.ham_rep > optim_b.ham_rep);
dv_upwind = Ib.*dv_b + If.*dv_f;
optim =  e1_optim_calc(dv_upwind, dv_2, w, z_act, z_hat, Sigma, xi, alpha_1, alpha_2, nu, phi_d, sigma_a, theta, Q, E_x, E_pi);
A_matrix = e1_construct_A_matrix(optim, d_state_space,I, num_state_vars, len_state);


 %SOLVE FOR NEW V
B = (rho + 1/Delta)*speye(len_state) - A_matrix;
b =  optim.pi_with_actions + V/Delta;
V = B\b;
Vchange = V - v;
v =  V;
%v = V;

[max_val, max_index ] = max(abs(Vchange));
dist(n) = max_val;
fprintf('max divergence: %g; mean divergence: %g\n',Vchange(max_index), mean(Vchange));

    if dist(n)<crit
            disp('Value Function Converged, Iteration = ')
            disp(n)
            break
    end
end

