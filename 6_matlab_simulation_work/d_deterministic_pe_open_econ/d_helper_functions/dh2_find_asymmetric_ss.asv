function [dual_output, num_firms, best_P] = dh2_find_asymmetric_ss(y, P0, grid_length, num_breaks,cutoff, params)
params.y = y; 
new_cache = {};
[new_cache{1}, best_value] = dual_inner_loop(params, P0,{});
best_P = P0;
while best_value > cutoff && grid_length > 1e-12
    [new_cache, best_P, best_value,grid_length] = grid_iteration(params, new_cache, num_breaks, grid_length, best_P);
end
distances = cellfun(@(entry) norm(best_P - entry.P), new_cache);
[~, idx] = min(distances);
dual_v = new_cache{idx}.dual_v;
[~,~,~,dual_output, num_firms] = dual_inner_loop(params, best_P, dual_v);

disp('hi')
end

%% WRAPPER FOR CHECKING ALL P COMBINAIONS IN THE GRID 
function [new_cache, best_P, best_value,grid_length] = grid_iteration(params,old_cache,num_breaks, grid_length, P0)
% setup the list of P to test 
lb = P0 - grid_length; ub = P0 + grid_length;
P1_vals = linspace(lb(1), ub(1), num_breaks); P2_vals = linspace(lb(2), ub(2), num_breaks);
[P1_grid, P2_grid] = ndgrid(P1_vals, P2_vals);
P_matrix = [P1_grid(:), P2_grid(:)];  

% iterate through P list 
new_cache = cell(size(P_matrix,1),1); values = zeros(size(new_cache)); miss_vec = zeros(size(P_matrix,1),2); num_firms = miss_vec;
parfor i = 1:size(P_matrix,1)
    P = P_matrix(i,:);
    distances = cellfun(@(entry) norm(P - entry.P), old_cache);
    [~, idx] = min(distances);
    dual_v = old_cache{idx}.dual_v;
    [new_cache{i}, values(i),miss_vec(i,:), ~,num_firms(i,:)] = dual_inner_loop(params,P, dual_v);
end

% find the best value 
[~,min_index] = min(values);
best_P = P_matrix(min_index,:);
best_value = sum(abs(miss_vec(min_index,:)));
num_firms = num_firms(min_index,:);
% update search box 
if all((best_P > lb) & (best_P < ub))
    grid_length = .5*grid_length;
else
    grid_length = 1.5*grid_length;
end
fprintf('miss value P = %g; miss value v = %g; num_firms = (%g,%g)\n',  miss_vec(min_index,1), miss_vec(min_index,2), num_firms(1), num_firms(2));
end

%% WRAPPER FOR FINDING THE MISS VALUE OF AN INDIVIDUAL P POINT 
function [cache_entry,value, miss_vec, dual_output,num_firms] = dual_inner_loop(params, P, in_dual_v)
dual_output = cell(1,2); out_dual_v = dual_output; dual_miss_val = dual_output;
for i = 1:2
    l_params = params;
    l_params.P = P;
    if i==2; l_params.P = flip(P); l_params.y = flip(l_params.y); end
    if isempty(in_dual_v)
        v_hjb = dh9_HJB_inner_loop(zeros(params.len_Sigma, params.num_networks),l_params);
        t_output = dh10_LCP_inner_loop(v_hjb, l_params, true);
    else
        t_output = dh10_LCP_inner_loop(in_dual_v{i}, l_params, true);
    end
    dual_output{i} = t_output;
    out_dual_v{i} = t_output.v;
    dual_miss_val{i} = t_output.entrance_v - params.ec(1);
end
% record how far the larger entrance value is from 0
v_miss = abs(max(dual_miss_val{:}));

%% DETETRMINE NUM FIRMS IN MARKET 
eta = 100;
m_bar = .1;
z   = max(min(eta*[dual_miss_val{:}], 40), -40);   % clip for overflow safety
m   = m_bar * exp(z);

% smooth how 'present' each country is in the market
dual_miss = [dual_miss_val{:}];          % 1x2, one per type
tau       = 1e-4;                      
eps_floor = 1e-10;                       
scale_adj = eps_floor + (1 - eps_floor) * exp(min(dual_miss,0) ./ tau);
%if all(dual_miss <0)
 %   scale_adj =  scale_adj .*(1-(dual_miss == min(dual_miss)));
%else
 %   scale_adj = 1 - (dual_miss <= 0);
%end
  

% gen params necessary for CES price index 
gamma = params.gamma;
p = [dual_output{1}.p; flip(dual_output{2}.p)];
A_1_raw = dual_output{1}.A_tilde_out .* params.networks(dual_output{1}.network_ss,:);
A_2_raw = dual_output{2}.A_tilde_out .* params.networks(dual_output{2}.network_ss,:);
A_1 = scale_adj(1) * A_1_raw; A_2 = scale_adj(2) * A_2_raw; A = [A_1 ; flip(A_2)];

% solve the formula 
%rhs = (P(:)).^(1-gamma); B = A .* (p.^(1-gamma)); num_firms = B\rhs; num_firms = num_firms .*(1- (num_firms<0));
%P_resid = sum(abs(B*num_firms - rhs));
[num_firms, P_resid] = solve_num_firms_numeric(P, A,p, params.gamma, params.sym_num_firms);

miss_vec = [P_resid; max(dual_miss_val{:})];
value = sum([P_resid; v_miss]);
cache_entry =  struct('P', {P}, 'dual_v', {out_dual_v});
end


function [num_firms, P_resid] = solve_num_firms_numeric(P, A, p, gamma, sym_num_firms)
    % Bounds 
    lb = zeros(2,1); ub = 4*sym_num_firms*ones(2,1);
    
    % Prep
    e = 1 - gamma;  rhs = (P(:)).^e;   B = A .* (p.^e);  
    num_firms_0 = sym_num_firms * ones(2,1);

    % Options
    opts = optimoptions('fmincon',  'Algorithm','interior-point', ...
        'Display','off', 'StepTolerance',1e-10,'OptimalityTolerance',1e-8);

    % Solve: minimize L1 residual
    obj = @(x) sum(abs(B*x - rhs));
    num_firms = fmincon(obj, num_firms_0, [],[],[],[], lb, ub, [], opts);
    P_resid = sum(abs(B*num_firms - rhs));
end
