clear all; close all; clc;
addpath(genpath('../b_helper_functions'))
addpath(genpath('d_helper_functions'))

%% === SET PARAMETER VALUES ===
% base parameters
I = 6;
num_mkts = 2;
LCP_yn =true;
networks = [0,0;1,0;1,1]; %networks = dec2bin(0:(2^num_mkts - 1)) - '0';
num_networks = size(networks,1);

% Simulation Parameters
rho = 0.05; %discount rate
Delta = 1000; % 1/Delta = time_step
crit = 10^(-3);
maxit = 500;

% production parameters
w = 1;
phi_g = 1; % goods productivity
gamma = 4;     % CES parameter (from BEJK)
gamma_tilde = gamma/(gamma-1);

% data parameters
phi_d = 1; % data productivity
alpha_1 = .5; % cobb douglas coefficient on data labor
alpha_2 = .5; % cobb douglas coefficient on raw data
sigma_a = repmat(1.1,1,num_mkts); % sd of noise term
theta = .9; % mean reversion parameter
lambda = .5; % correlation coefficient between mkts 
sigma_z = repmat(1.1,1,num_mkts);

%% === Construct State Space and Derived Params ===
[Q,D,Sigma] = dh1_make_state_space(num_mkts,I, lambda, sigma_z, theta);
Sigma_mat = dh2_restructure_array(repmat(Sigma,1,1,num_networks),true, num_mkts);

% ancillary params 
num_state_vars = size(Sigma,2);
len_Sigma = size(Sigma,1);
d_Sigma =  (Sigma(len_Sigma, :) - Sigma(1,:))/(I-1);
diag_indeces = find(ismember(find(triu(true(num_mkts), 0)),1:num_mkts+1:num_mkts^2));

% Construct Expected Quality / Quantity / Profits 
penalty = sigma_a.^2 + Sigma(:,diag_indeces);
A_bar = max(penalty) + (max(penalty)-min(penalty));
A_tilde = A_bar - penalty;
x_bar = 1./min(A_tilde); % base demand 
pi_bar = x_bar*w*phi_g^-1*(gamma-1)^-1; % base profits 
E_x = x_bar .* A_tilde .* permute(networks, [3 2 1]);  
E_pi = pi_bar .* A_tilde .* permute(networks, [3 2 1]);
xi = alpha_1*phi_d*E_x.^alpha_2;

%% ==== SET INITIAL GUESS FOR VALUE FUNCTION 
% determine zero drift state in network[1,0] 2 w/o data 
init_index = dh3_determine_init_index(Sigma_mat,Sigma, D,Q,sigma_a,num_mkts);
working_profit_base = sum(E_pi(init_index,:,2));
fc = working_profit_base; fc = [fc, repmat(fc*1.3,1,num_mkts-1)];
ec = fc*2; rev_ec = repmat(.001,1, num_mkts);

% initial guess is zero; value of staying in zero drift state forever 
v0 = zeros(len_Sigma, num_networks);
v = v0;

%% ==== Perform Value Function Iteration  
for n=1:maxit

% establish derivative approximations
[dv_f, dv_b] = dh4_make_derivatives(v, I, num_state_vars, num_networks, d_Sigma);

% carry out the upwind 
dv_final = dh6_upwind(dv_b, dv_f, Sigma_mat, Q, D, w, phi_d, alpha_1, alpha_2, sigma_a, networks, E_x, E_pi, xi, fc);

% determine optimal behavior 
optim =  dh5_optim_calc(dv_final, Sigma_mat, Q, D, w, phi_d, alpha_1, alpha_2, sigma_a, networks, E_x, E_pi, xi, fc);

% construct the transition matrix 
A_matrix = dh7_make_A_matrix(optim.drift,d_Sigma);

% update V
V = dh8_update_V(LCP_yn,optim.profit_w_actions,v, A_matrix, rho, Delta, networks, ec, rev_ec);

% prepare for next iteration 
change = max(abs(V(:) - v(:)));
fprintf('change = %d\n',change)
dist(n) = change;
Vchange = V - v;
v = V;

if dist(n)<crit
    disp('Value Function Converged, Iteration = ')
    disp(n)
    break
end
end

