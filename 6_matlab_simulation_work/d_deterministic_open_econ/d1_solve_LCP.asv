clear all; close all; clc;
addpath(genpath('../b_helper_functions'))
addpath(genpath('d_helper_functions'))


%% == Set key parameters ==
I = 20;
num_mkts = 2;
LCP_yn =false;
networks = [1,0;1,1]; %networks = [0,0;1,0;1,1]; %networks = dec2bin(0:(2^num_mkts - 1)) - '0';
num_networks = size(networks,1);

w = 1; % data worker wage
phi_d = 1; % data productivity 
alpha_1 = .5;  % cobb douglas coefficient on data labor 
alpha_2 = .5; % cobb douglas coefficient on raw data 
top_bottom_quality_ratio = 2; % how much data helps improve quality 
x_scale_factor = repmat(20, 1,num_mkts); % what is underlying level of demand 
phi_g = 1;
sigma_z = repmat(1.1,1,num_mkts); % variance of random component of z
theta = .9; % mean reversion parameter of z (closer to one faster mean reversion)
lambda_tilde = .5; % correlation coefficient between mkts 
fixed_cost_scaling = 1.1; %fc * fixed_cost_scaling = foreign market fixed costs 
ec_multiplier = .01; % fc * ec_multiplier = ec 


%% == Set other parameters ==
% Simulation Parameters
rho = 0.05; %discount rate
Delta = 1000; % 1/Delta = time_step
crit = 10^(-4);
maxit = 1000;

% production / data parameters
w_g = 1; % wage for production workers
gamma = 4;     % CES parameter (from BEJK)
gamma_tilde = gamma/(gamma-1);
x_bar = x_scale_factor*phi_g^gamma; % base demand 
pi_bar = x_bar*w_g*phi_g^-1*(gamma-1)^-1; % base profits 
sigma_a = repmat(1.1,1,num_mkts); % sd of noise term
rev_ec = repmat(.001,1, num_mkts); % exit costs from market 

%% === Construct State Space and Derived Params ===
[Q,D,Sigma] = dh1_make_state_space(num_mkts,I, lambda_tilde, sigma_z, theta);
Sigma_mat = dh2_restructure_array(repmat(Sigma,1,1,num_networks),true, num_mkts);

% ancillary params 
num_state_vars = size(Sigma,2);
len_Sigma = size(Sigma,1);
d_Sigma =  (Sigma(len_Sigma, :) - Sigma(1,:))/(I-1);
diag_indeces = find(ismember(find(triu(true(num_mkts), 0)),1:num_mkts+1:num_mkts^2));

% Construct Expected Quality / Quantity / Profits 
A_tilde = dh0_gen_A_tilde(top_bottom_quality_ratio,Sigma, sigma_a, diag_indeces);
E_x = x_bar.*A_tilde.* permute(networks, [3 2 1]);
E_pi = pi_bar.*A_tilde.* permute(networks, [3 2 1]); % Expected working profits (not accounting for fixed costs; data labor)
xi = alpha_1*phi_d*E_x.^alpha_2;


%% ==== SET INITIAL GUESS FOR VALUE FUNCTION 
[v0,fc,ec] = dh3_set_v0_fc_ec(Sigma_mat,Sigma, D,Q,sigma_a,...
    pi_bar, A_tilde,networks, fixed_cost_scaling,ec_multiplier, rho);

v = v0;

%% ==== Perform Value Function Iteration ===
for LCP_yn = [false,true]
for n=1:maxit

% establish derivative approximations
[dv_f, dv_b] = dh4_make_derivatives(v, I, num_state_vars, num_networks, d_Sigma);

% carry out the upwind 
dv_final = dh6_upwind(dv_b, dv_f, Sigma_mat, Q, D, w, phi_d, alpha_1, alpha_2, sigma_a, networks, E_x, E_pi, xi, fc);

% determine optimal behavior 
optim =  dh5_optim_calc(dv_final, Sigma_mat, Q, D, w, phi_d, alpha_1, alpha_2, sigma_a, networks, E_x, E_pi, xi, fc);

% construct the transition matrix 
[A_matrix, A_matrix_cells] = dh7_make_A_matrix(optim.drift,d_Sigma);

% update V
[V,z,best_alt] = dh8_update_V(LCP_yn,optim.profit_w_actions,v, A_matrix,A_matrix_cells, rho, Delta, networks, ec, rev_ec);

% prepare for next iteration 
Vchange = V - v;
v =  .9*v +.1*V;
[max_val, max_index ] = max(abs(Vchange(:)));
dist(n) = max_val;
fprintf('max divergence: %g; mean divergence: %g\n',Vchange(max_index), mean(Vchange(:)));
if dist(n)<crit
    fprintf('Value Function Converged, Iteration = %g\n',n)
    break
end
end

end


%% ===Simulate firm trajectory starting at Sigma_ub===


% setup 
T = 1000;                 
Sigma_path = zeros(T, num_state_vars);
data_use_path = zeros(T, num_mkts); 
output_path = zeros(T, num_mkts);
profit_path = zeros(T, 1);
network_path = ones(T,1);
% determine if firm will change networks 
preferred_network = repmat(1:num_networks, len_Sigma,1).*(reshape(z,[],num_networks)>0) +...
                    best_alt.*(reshape(z,[],num_networks) ==0);

% establish starting state 
Sigma_path(1, :)= Sigma(len_Sigma,:);
for t = 1:T
    Sigma_t = Sigma_path(t,:);
    network_t = network_path(t);
    [indices, weights] = fh11_interp_box(Sigma_t, Sigma, 2);
    data_use_path(t,:) =  sum(optim.L(indices, :, network_t) .* weights); 
    output_path(t,:) =  sum(E_x(indices, :, network_t) .* weights); 
    profit_path(t,:) = sum(optim.profit_w_actions(indices, network_t).*weights);
    drift_t = sum(optim.drift(indices,:,network_t).*weights);

    if (t ~= T)
        Sigma_path(t+1,:) = Sigma_t + drift_t*1/Delta;
        [indices, weights] = fh11_interp_box( Sigma_path(t+1,:),Sigma, 2);
        best_score = -inf; best_network = 1; pref_base = [preferred_network(indices,network_t),weights];
        for network = 1:num_networks
          score = sum(pref_base(pref_base(:,1) == network, 2));
          if score > best_score 
              best_score = score; best_network = network;
          end
        end
        network_path(t+1) = best_network;
    end 
end

netw